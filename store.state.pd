#N canvas 400 196 803 476 10;
#X obj 100 30 cnv 15 110 35 empty empty empty 20 12 0 14 -204786 -66577
0;
#X obj 500 30 cnv 15 200 150 empty empty empty 20 12 0 14 -204786 -66577
0;
#X floatatom 110 125 5 0 100 1 number1 #0-number1.r #0-number1.s;
#X floatatom 110 145 5 0 100 1 number2 #0-number2.r #0-number2.s;
#X floatatom 110 165 5 0 100 1 number3 #0-number3.r #0-number3.s;
#X obj 220 125 hradio 15 1 0 8 \$0-hradio.s \$0-hradio.r hradio 0 -8
0 10 -262144 -1 -1 3;
#X obj 110 207 vsl 15 128 0 127 0 0 \$0-slider.s \$0-slider.r slider
0 -9 0 10 -262144 -1 -1 12000 1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-array1 100 float 2;
#X coords 0 1 100 -1 200 140 1 0 0;
#X restore 180 205 graph;
#N canvas 285 333 826 406 store.state 0;
#X text 253 141 SEND: \$0-<parameter_name>.s;
#X text 253 161 RECEIVE: \$0-<parameter_name>.r;
#X obj 50 82 store.param \$0 number1;
#X obj 50 102 store.param \$0 number2;
#X obj 50 122 store.param \$0 number3;
#X obj 50 142 store.param \$0 slider;
#X obj 50 162 store.param \$0 hradio;
#X obj 50 222 store.array \$0 array1;
#N canvas 81 45 329 237 read.write 0;
#X obj 74 111 savestate;
#X obj 74 91 r \$0-to.savestate;
#X obj 125 131 s \$0-savestate.right;
#X text 78 33 send and receive lists from the individual abstractions
, f 27;
#X obj 74 171 s \$0-savestate.left;
#X obj 74 131 t a b;
#X obj 101 151 s \$0-stop.loadbang;
#X connect 0 0 5 0;
#X connect 0 1 2 0;
#X connect 1 0 0 0;
#X connect 5 0 4 0;
#X connect 5 1 6 0;
#X restore 50 32 pd read.write;
#X obj 50 292 store.text \$0 text1;
#X text 253 341 With this method it's still required to create a new
[store.param] (or [store.array] or [store.text]) abstraction for every
parameter or table to be saved \, but at least there is no need to
patch all the send and receives individually., f 84;
#X text 253 221 Arrays can be saved as well with the [store.array]
object. The first argument is \$0 \, the second is the name of the
array without \$0-. The object on the left will save the content of
a table named "\$0-array1"., f 84;
#X text 253 31 This is the read/write subpatch which should be left
as-is., f 84;
#X text 253 81 In order for a parameter that is in the abstraction
to be saved in the parent patch \, here there needs to be a [store.param]
abstraction with the name of that parameter as the second argument
(whilst the first argument is always \$0). The send and receive symbols
for each parameter must be formated in this way:, f 84;
#X text 253 291 Text objects can be saved in a similar way to arrays
with this object [store.text]., f 84;
#X restore 110 40 pd store.state;
#X text 216 30 This is the subpatch to copy into your abstraction and
adapt to your needs. Look inside for more details., f 31;
#X obj 100 425 text define \$0-text1;
#X obj 510 40 loadbang;
#X obj 510 60 spigot 1;
#X msg 570 60 0;
#X obj 510 80 f \$0;
#X msg 510 100 \; \$1-number1.r 50 \; \$1-number2.r 100 \; \$1-number3.r
200 \; \$1-slider.r 0 \; \$1-hradio.r 3 \;;
#X obj 570 40 r \$0-stop.loadbang;
#X text 240 416 this doesn't show up in the graph-on-parent but is
saved as well., f 25;
#X text 490 195 [savestate] output comes before [loadbang] \, this
mechanism was suggested by Miller in the Pd list and allows to set
default values for the controls which will be used whenever there is
no state saving in the parent patch. If you open this file (store.state.pd)
it'll load with these values., f 38;
#X obj 220 155 bng 15 250 50 0 \$0-open.text empty open.text.object
17 7 0 10 -262144 -1 -1;
#X obj 100 385 r \$0-open.text;
#X msg 100 405 click;
#X connect 11 0 12 0;
#X connect 12 0 14 0;
#X connect 13 0 12 1;
#X connect 14 0 15 0;
#X connect 16 0 13 0;
#X connect 20 0 21 0;
#X connect 21 0 10 0;
#X coords 0 -1 1 1 300 260 1 100 100;
